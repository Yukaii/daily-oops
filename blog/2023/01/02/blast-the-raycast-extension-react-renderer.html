<!DOCTYPE html><html lang="zh-Hant-TW" data-dark-theme="dark"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="color-scheme" content="dark light"/><title>Blast：一個能執行 Raycast 擴充功能的 React.js 渲染器 | Daily Oops!</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="
# Blast：一個能執行 Raycast 擴充功能的 React.js 渲染器

2023 年新年快樂！新年有什麼一定要做的事呢？對我來說就是挖新坑寫新專案無誤！這次的專案叫做 Blast，就如標題寫的，它是一個「能執行 Raycast 擴充功能的 React.js 渲染器（Renderer）」"/><meta property="og:title" content="Blast：一個能執行 Raycast 擴充功能的 React.js 渲染器"/><meta property="og:description" content="
# Blast：一個能執行 Raycast 擴充功能的 React.js 渲染器

2023 年新年快樂！新年有什麼一定要做的事呢？對我來說就是挖新坑寫新專案無誤！這次的專案叫做 Blast，就如標題寫的，它是一個「能執行 Raycast 擴充功能的 React.js 渲染器（Renderer）」"/><meta property="og:url" content="https://yukaii.tw/blog/2023/01/02/blast-the-raycast-extension-react-renderer"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2023-01-02T00:00:00+00:00"/><meta property="article:modified_time" content="2023-01-02T00:00:00+00:00"/><meta property="og:locale" content="zh-Hant-TW"/><meta property="og:site_name" content="Daily Oops!"/><meta name="next-head-count" content="15"/><link rel="alternate" type="application/rss+xml" title="RSS feed for blog posts" href="https://yukai.dev/feed.xml"/><div><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-L4KRS0HB4B"></script><script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){dataLayer.push(arguments);}
                    window.gtag = gtag
                    gtag('js', new Date());
  
                    gtag('config', 'G-L4KRS0HB4B', {
                      page_path: window.location.pathname,
                    });
                  </script></div><link rel="preload" href="/_next/static/css/13335a39f4847e4c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/13335a39f4847e4c.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8af02d8311da3a26.js" defer=""></script><script src="/_next/static/chunks/framework-8d78bf989db74c8f.js" defer=""></script><script src="/_next/static/chunks/main-672ebd1afcdc5438.js" defer=""></script><script src="/_next/static/chunks/pages/_app-7295cacef859375c.js" defer=""></script><script src="/_next/static/chunks/9e22d361-1e7692863daad2ac.js" defer=""></script><script src="/_next/static/chunks/290-cf8ff80c4951daab.js" defer=""></script><script src="/_next/static/chunks/224-4cef2e4da6030653.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-ce01b329ac7b6ac5.js" defer=""></script><script src="/_next/static/BIh5gQ5s5AG9U8UJ_rYWZ/_buildManifest.js" defer=""></script><script src="/_next/static/BIh5gQ5s5AG9U8UJ_rYWZ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,n='data-color-mode',s='setAttribute';var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';d[s](n,'dark')}else{d.style.colorScheme = 'light';d[s](n,'light')}}else if(e){d[s](n,e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="d-flex text-center color-bg-secondary py-4 px-3 header-block flex-items-center small flex-justify-center"><div class="CircleBadge user-select-none CircleBadge--small mr-2" style="overflow:hidden;background-color:#F5CC7F"><img alt="Daily Oops" src="/_next/static/media/logo-animated.00a7e7a1.gif" width="300" height="300" decoding="async" data-nimg="1" loading="lazy" style="color:transparent;height:auto;max-width:90%"/></div><h1 class="d-flex flex-items-center flex-justify-center">Daily Oops!</h1></div><nav class="UnderlineNav color-bg-secondary px-3 position-sticky top-0 flex-items-center flex-justify-center" style="z-index:99"><div class="UnderlineNav-body" role="tablist" style="max-width:100%"><a href="/"><button class="UnderlineNav-item" role="tab" type="button" aria-selected="false"><svg aria-hidden="true" role="img" class="UnderlineNav-octicon" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom"><path fill-rule="evenodd" d="M3.499.75a.75.75 0 011.5 0v.996C5.9 2.903 6.793 3.65 7.662 4.376l.24.202c-.036-.694.055-1.422.426-2.163C9.1.873 10.794-.045 12.622.26 14.408.558 16 1.94 16 4.25c0 1.278-.954 2.575-2.44 2.734l.146.508.065.22c.203.701.412 1.455.476 2.226.142 1.707-.4 3.03-1.487 3.898C11.714 14.671 10.27 15 8.75 15h-6a.75.75 0 010-1.5h1.376a4.489 4.489 0 01-.563-1.191 3.833 3.833 0 01-.05-2.063 4.636 4.636 0 01-2.025-.293.75.75 0 11.525-1.406c1.357.507 2.376-.006 2.698-.318l.009-.01a.748.748 0 011.06 0 .75.75 0 01-.012 1.074c-.912.92-.992 1.835-.768 2.586.221.74.745 1.337 1.196 1.621H8.75c1.343 0 2.398-.296 3.074-.836.635-.507 1.036-1.31.928-2.602-.05-.603-.216-1.224-.422-1.93l-.064-.221c-.12-.407-.246-.84-.353-1.29a2.404 2.404 0 01-.507-.441 3.063 3.063 0 01-.633-1.248.75.75 0 011.455-.364c.046.185.144.436.31.627.146.168.353.305.712.305.738 0 1.25-.615 1.25-1.25 0-1.47-.95-2.315-2.123-2.51-1.172-.196-2.227.387-2.706 1.345-.46.92-.27 1.774.019 3.062l.042.19a.753.753 0 01.01.05c.348.443.666.949.94 1.553a.75.75 0 11-1.365.62c-.553-1.217-1.32-1.94-2.3-2.768a85.08 85.08 0 00-.317-.265c-.814-.68-1.75-1.462-2.692-2.619a3.74 3.74 0 00-1.023.88c-.406.495-.663 1.036-.722 1.508.116.122.306.21.591.239.388.038.797-.06 1.032-.19a.75.75 0 01.728 1.31c-.515.287-1.23.439-1.906.373-.682-.067-1.473-.38-1.879-1.193L.75 5.677V5.5c0-.984.48-1.94 1.077-2.664.46-.559 1.05-1.055 1.673-1.353V.75z"></path></svg><span>Home</span></button></a><a href="/blog"><button class="UnderlineNav-item" role="tab" type="button" aria-selected="false"><svg aria-hidden="true" role="img" class="UnderlineNav-octicon" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom"><path fill-rule="evenodd" d="M0 1.75A.75.75 0 01.75 1h4.253c1.227 0 2.317.59 3 1.501A3.744 3.744 0 0111.006 1h4.245a.75.75 0 01.75.75v10.5a.75.75 0 01-.75.75h-4.507a2.25 2.25 0 00-1.591.659l-.622.621a.75.75 0 01-1.06 0l-.622-.621A2.25 2.25 0 005.258 13H.75a.75.75 0 01-.75-.75V1.75zm8.755 3a2.25 2.25 0 012.25-2.25H14.5v9h-3.757c-.71 0-1.4.201-1.992.572l.004-7.322zm-1.504 7.324l.004-5.073-.002-2.253A2.25 2.25 0 005.003 2.5H1.5v9h3.757a3.75 3.75 0 011.994.574z"></path></svg><span>Blog</span></button></a><a href="/projects"><button class="UnderlineNav-item" role="tab" type="button" aria-selected="false"><svg aria-hidden="true" role="img" class="UnderlineNav-octicon" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom"><path fill-rule="evenodd" d="M2 2.5A2.5 2.5 0 014.5 0h8.75a.75.75 0 01.75.75v12.5a.75.75 0 01-.75.75h-2.5a.75.75 0 110-1.5h1.75v-2h-8a1 1 0 00-.714 1.7.75.75 0 01-1.072 1.05A2.495 2.495 0 012 11.5v-9zm10.5-1V9h-8c-.356 0-.694.074-1 .208V2.5a1 1 0 011-1h8zM5 12.25v3.25a.25.25 0 00.4.2l1.45-1.087a.25.25 0 01.3 0L8.6 15.7a.25.25 0 00.4-.2v-3.25a.25.25 0 00-.25-.25h-3.5a.25.25 0 00-.25.25z"></path></svg><span>Projects</span></button></a><a href="/about"><button class="UnderlineNav-item" role="tab" type="button" aria-selected="false"><svg aria-hidden="true" role="img" class="UnderlineNav-octicon" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom"><path fill-rule="evenodd" d="M10.5 5a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0zm.061 3.073a4 4 0 10-5.123 0 6.004 6.004 0 00-3.431 5.142.75.75 0 001.498.07 4.5 4.5 0 018.99 0 .75.75 0 101.498-.07 6.005 6.005 0 00-3.432-5.142z"></path></svg><span>About</span></button></a></div></nav><section><div><div class="container pt-4 pb-3 px-3"><span class="text-mono color-text-tertiary">January 2, 2023</span></div><div><main id="main" property="schema:mainEntity"><article itemscope="" itemProp="post" typeof="schema:Article schema:BlogPosting" property="schema:articleBody" class="markdown-body container post-container px-3"><h1 id="blast%EF%BC%9A%E4%B8%80%E5%80%8B%E8%83%BD%E5%9F%B7%E8%A1%8C-raycast-%E6%93%B4%E5%85%85%E5%8A%9F%E8%83%BD%E7%9A%84-react.js-%E6%B8%B2%E6%9F%93%E5%99%A8"><a class="anchor" href="#blast%EF%BC%9A%E4%B8%80%E5%80%8B%E8%83%BD%E5%9F%B7%E8%A1%8C-raycast-%E6%93%B4%E5%85%85%E5%8A%9F%E8%83%BD%E7%9A%84-react.js-%E6%B8%B2%E6%9F%93%E5%99%A8"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> Blast：一個能執行 Raycast 擴充功能的 React.js 渲染器</h1>
<p>2023 年新年快樂！新年有什麼一定要做的事呢？對我來說就是挖新坑寫新專案無誤！這次的專案叫做 Blast，就如標題寫的，它是一個「能執行 Raycast 擴充功能的 React.js 渲染器（Renderer）」。</p>
<h2 id="raycast-%E5%92%8C-react.js"><a class="anchor" href="#raycast-%E5%92%8C-react.js"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> Raycast 和 React.js</h2>
<p>對於第一次聽到 <a href="https://www.raycast.com/">Raycast</a> 的朋友，我以前也寫過一篇<a href="https://yukai.dev/blog/2022/05/20/raycast-for-developers">推坑文</a>，Raycast 是一套 macOS 用的啟動器軟體（Launcher），提供一個關鍵字搜尋的介面，輸入關鍵字，就能快速啟動程式或進行其他操作。過往類似的軟體也不少，最知名的就是 <a href="https://www.alfredapp.com/">Alfred</a>，但 Raycast 最不同的一點，就是可以用 React.js 來寫的擴充功能。這邊我之前的文章也有<a href="https://yukai.dev/blog/2022/05/20/raycast-for-developers">簡略帶過</a>，大家可以看官方的 <a href="https://github.com/raycast/extensions/tree/main/examples/todo-list">todo-list 範例</a>感受一下，有點像在寫 React Native，雖然寫的是 JavaScript，但卻能有原生的介面而非網頁。</p>
<p>React.js 相信近年熟悉前端開發的朋友應該都多少接觸過（斷言），React.js 提供了聲明式（Declarative）的 API 來開發使用者介面（User Interface），而使用者介面可以用階層、樹狀的結構來表示，去看看設計師 Figma/illustrator/Sketch 裡的圖層和群組物件就有感覺了，有的設計工具甚至還提供「輸出 React.js 元件」的功能。</p>
<p>剛提到了「用 React 來實作使用者元件」，React 核心就是一套 Virtual DOM/Diff/Update 的邏輯，無關終端平臺為合，Android、iOS 還是 Desktop，只要你實作 React 提供的介面，什麼平臺都可以寫 React，所以才有了 React Native 等<a href="https://github.com/chentsulin/awesome-react-renderer">一眾自定渲染器</a>（Custom Renderer）。</p>
<p>Raycast 能夠用 React 來寫擴充功能，也是內嵌（ㄑㄧㄢ，誰這裡念砍我就…）Node.js 並實作渲染器。寫到這，Raycast 和 React 和 Renderer 的關係，大家應該多瞭解一咪咪了吧 XD 下面就來講講我為何決定做這個題目。</p>
<h2 id="%E5%8B%95%E6%A9%9F"><a class="anchor" href="#%E5%8B%95%E6%A9%9F"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> 動機</h2>
<p>七個字：Raycast 我推我超！</p>
<p>從擴充功能 API 上線一年多以來，我已經寫了<a href="https://www.raycast.com/Yukai">十個 Raycast 擴充功能</a>，還因此收到了 Raycast 寄來的<a href="https://www.facebook.com/photo.php?fbid=6185229718163261&amp;set=p.6185229718163261&amp;type=3">開發者大禮包</a>。Raycast 有著 <strong>Tier 0</strong> 的開發者體驗，雖說頭幾個寫的擴充功能拿來練手成分比較高，但後期開發的擴充功能如 <a href="https://www.raycast.com/Yukai/hackmd">HackMD</a> ，我自己都天天在用啊，開筆記搜筆記都超快超方便的（棒讀業配環節）</p>
<p>另一個比較黑的理由就是我內心的<a href="https://lycoris-recoil.com/">平衡人真島大哥</a>在作祟！隨著 Raycast 開發者社群的壯大，截止行文當日（2023/1/2）已上架 742 個擴充功能，雖然擴充功能的開源授權為 MIT，但除了拿來做擴充功能開發做參考外，這些擴充功能也只能跑在 Raycast 的封閉平臺上，除了僅限一家也僅限 macOS 一個平臺。</p>
<p>我就想到 <a href="https://vscodium.com/">VSCodium</a> 這個專案，雖然 VSCode 也是開放程式碼，但實際上的發佈版，還是包了遙測和一些追蹤碼。欸，全球的<strong>軟黑產業鏈</strong>似乎都動起來了！VSCodium 就是把 VSCode 有疑慮的授權程式碼部分和遙測通通拔掉，重新發佈的「乾淨版」。這樣 484 在臭各種 SaaS 產品啊 XD</p>
<p>至於擴充功能商店的部分當然也不放過，<a href="https://open-vsx.org/">Open VSX</a> 是一個提供相容 VSCode 編輯器的擴充功能商店。VSCode 至今已經被作為各個開源 IDE/編輯器的基礎元件來使用，比如用 Theia IDE 做的 IDE 們，就是相容 VSCode 擴充功能的 IDE。Open VSX 讓這些支援的編輯器也能免費擼 VSCode 平臺的擴充功能，打不贏就加入！</p>
<p>總之，「<strong>讓 Raycast 的擴充功能被跨平臺並開放地使用</strong>」，就是本專案的目標！Show me what you got!</p>
<h2 id="%E9%96%8B%E7%99%BC-blast"><a class="anchor" href="#%E9%96%8B%E7%99%BC-blast"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> 開發 Blast</h2>
<p><a href="https://github.com/Yukaii/blast">Blast</a> 就是基於上述理由所發起的專案。這兩週陸陸續續的開發過程可以分成三個階段：</p>
<ul>
<li>架構設計、技術選擇與基本踩雷試錯</li>
<li>React 渲染器 &amp; 後端開發</li>
<li>Client App 開發</li>
</ul>
<h3 id="%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88%E3%80%81%E6%8A%80%E8%A1%93%E9%81%B8%E6%93%87%E8%88%87%E5%9F%BA%E6%9C%AC%E8%B8%A9%E9%9B%B7%E8%A9%A6%E9%8C%AF"><a class="anchor" href="#%E6%9E%B6%E6%A7%8B%E8%A8%AD%E8%A8%88%E3%80%81%E6%8A%80%E8%A1%93%E9%81%B8%E6%93%87%E8%88%87%E5%9F%BA%E6%9C%AC%E8%B8%A9%E9%9B%B7%E8%A9%A6%E9%8C%AF"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> 架構設計、技術選擇與基本踩雷試錯</h3>
<p>開發過程和往常一樣，都丟在我的 <a href="https://github.com/Yukaii/blast">GitHub</a> 上，這次還額外開了 <a href="https://github.com/users/Yukaii/projects/4">Project Board</a> 來試用。</p>
<p>一開始我就<a href="https://github.com/Yukaii/blast/issues/3">決定目標</a>：要把 Raycast 官方擴充功能範例中 <a href="https://github.com/raycast/extensions/tree/main/examples/todo-list">Todo List</a> 原汁原味一刀未減的跑起來。寫完這張 Ticket 後，就開始研究 Custom React renderer 該怎麼實作，最後找到 Jam Risser 的 <a href="https://www.youtube.com/watch?v=SXx-CymMjDM">Building a Custom React Renderer</a>，演講內容和程式碼範例都相當清楚，值得參考。</p>
<p>再來就是撞牆階段，一開始問 ChatGPT 用 Rollup 該怎麽設定 package alias，因為原始的 Raycast 擴充功能會用 <code>import { XXX } from '@raycast/api'</code>，而 <code>@raycast/api</code> 正式要替換為我自己實作的部分。沒想到開始用 Rollup 才是噩夢的開始，因為我要做的是 Application，鐵定會有一堆有的沒的相依套件，但我本來想把寫的程式打包成 ESM，於是在浪費一堆時間後就直接果斷換回熟悉的 Webpack，半小時內搞定 XD</p>
<p>在瘋狂搗鼓 React Renderer 並有了基本理解後，我設計了以下的架構：</p>
<figure data-type="image"><img src="https://hackmd.io/_uploads/rJmutOg9j.png" alt=""></figure>
<p>明明是個本機跑的 Launcher App 卻還要弄前後端？這裡的設計我很大的參考了早期的 React native。要寫一個自己的 React Renderer，我們會用到 <code>react-reconciler</code> 這個套件，並且實現 Host Config，大概會像<a href="https://github.com/Yukaii/blast/blob/b201eded481b8c54b3e3f38e2284a44a86dd0aee/src/reconciler.ts#L39-L77">這個檔案一樣</a>：</p>
<pre><code class="language-javascript"><button class="btn copy-snippet-button position-absolute top-1 right-1"><i class="fas fa-clipboard"></i><i class="fas fa-check"></i></button><table class="fence-wrapper"><tbody><tr><td class="hljs-line-number" data-line-number=1></td><td class="hljs-line" id="LC1"><span class="hljs-keyword">import</span> Reconciler <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-reconciler&quot;</span>;</td></tr><tr><td class="hljs-line-number" data-line-number=2></td><td class="hljs-line" id="LC2"></td></tr><tr><td class="hljs-line-number" data-line-number=3></td><td class="hljs-line" id="LC3"><span class="hljs-keyword">const</span> MyCustomReactRenderer = Reconciler({</td></tr><tr><td class="hljs-line-number" data-line-number=4></td><td class="hljs-line" id="LC4">  <span class="hljs-function"><span class="hljs-title">createInstance</span>(<span class="hljs-params">type, props, rootContainerInstance, hostContext, internalInstanceHandle</span>)</span> {</td></tr><tr><td class="hljs-line-number" data-line-number=5></td><td class="hljs-line" id="LC5">    <span class="hljs-comment">// ....</span></td></tr><tr><td class="hljs-line-number" data-line-number=6></td><td class="hljs-line" id="LC6">  },</td></tr><tr><td class="hljs-line-number" data-line-number=7></td><td class="hljs-line" id="LC7">  <span class="hljs-function"><span class="hljs-title">appendChildToContainer</span>(<span class="hljs-params">container, child</span>)</span> {</td></tr><tr><td class="hljs-line-number" data-line-number=8></td><td class="hljs-line" id="LC8">    <span class="hljs-comment">// ...</span></td></tr><tr><td class="hljs-line-number" data-line-number=9></td><td class="hljs-line" id="LC9">  }</td></tr><tr><td class="hljs-line-number" data-line-number=10></td><td class="hljs-line" id="LC10">})</td></tr></tbody></table></code></pre>
<p>Host Config 就是 Reconciler 函式的參數。你會看到一些類似操作 DOM 的方法，例如 <code>appendChild</code>，<code>removeChild</code> 等，因為那就是實作給 React 內部更新機制：Reconciliation 呼叫的方法。React 經由一系列騷操作，決定要更新的內容時，就會呼叫 Host Config 提供的方法，更新內容到你的目標平臺上。比如 <a href="https://github.com/facebook/react/blob/de7d1c90718ea8f4844a2219991f7115ef2bd2c5/packages/react-dom-bindings/src/client/ReactDOMHostConfig.js">ReactDOM 就是實作了操作 DOM 的 Host Config</a>，React.js 才能將元件渲染到網頁上。</p>
<p>上一段極其簡陋的說明了 React renderer 和 reconciler 的關係。說回來 React Native，在之前的 React Native 版本，Renderer 部分運用 Bridge Service，讓 JS engine 與 Native 部分溝通，你可以想象 React 內部在構建一顆樹狀結構，所以呼叫 <code>appendChild</code> 那些方法，Renderer 會把這些操作和參數佇列轉成 JSON 送到 Bridge，讓訂閱 Bridge 的 Native 端也一樣建造一棵樹（Shadow Tree），Native 端再由這顆樹狀的資料結構將原生的元件產生出來。</p>
<p>之前的 React Native 用 JSON Bridge 來溝通，那 Blast 也用這個方法就好？但 React Native 傳送的是建造樹的操作過程（operation），在 Native 端還要實作各個方法，讓 Native 端也能依照操作建立樹結構。不過我沒有甚麼效能要求，直接透過 JSON 序列化傳送整顆樹過去還比較快，使用者端甚至還可以用 React.js 直接把樹渲染，反正 React 會幫我處裡 Diffing/Re-render，我只要負責把 React Component Tree 建出來就好啦！<strong>Use React Everywhere</strong>！<strong>Learn Once Write Everywhere</strong>！諾貝爾獎是我的啦！好耶！！！努力！未來！A Beautiful Star！</p>
<p>以上就是在摸索中慢慢確立的 Blast 架構，剩下來的就是：實作！實作！實作！</p>
<h3 id="react-%E6%B8%B2%E6%9F%93%E5%99%A8-%26-%E5%BE%8C%E7%AB%AF%E9%96%8B%E7%99%BC"><a class="anchor" href="#react-%E6%B8%B2%E6%9F%93%E5%99%A8-%26-%E5%BE%8C%E7%AB%AF%E9%96%8B%E7%99%BC"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> React 渲染器 &amp; 後端開發</h3>
<p>老實說這部分在主架構實作完後就沒遇到太多困難，都是在填肉。比較值得一提的是我用了 <a href="https://github.com/elpheria/rpc-websockets"><code>rpc-websocket</code></a> 這套雙向 RPC 溝通的 Library。</p>
<p>為何需要雙向？在上面提到的 Blast 架構中，前端需要拿到後端建立的 Component Tree（client request server），後端在更新時也需要通知前端（server request client），前端有事件需要觸發時，也需要通知後端（client request server），所以請求其實是雙向的。RPC library 會幫你處理好 function parameter serialization/deserialization/dynamic event registration 等麻煩事，所以直接找一套現有的還是最快。謝謝你，開源超人。</p>
<h3 id="client-app-%E9%96%8B%E7%99%BC"><a class="anchor" href="#client-app-%E9%96%8B%E7%99%BC"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> Client App 開發</h3>
<p>最後就是麻煩但挑戰性相對本專案後端低的前端部分。本來想試一下 <a href="https://tauri.app/">Tauri</a> 還是 <a href="https://wails.io/">Wails</a> 的，但查了一下 menubar API 的部分還是那個萬惡 JS World 的 Electron 支援比較完整及簡單，反正就是層 Web 皮嘛，就還是用了 Electron（逃）</p>
<p>下面的動圖是 Blast 前端的 DevTool，可以看到目前渲染的 JSON Component Tree 長怎麼樣，也可以送 <code>rpc</code> 的事件給後端。</p>
<figure data-type="image"><img src="https://hackmd.io/_uploads/BJqFK_x9s.png" alt=""></figure>
<p>元件部分，除了 Tailwind/TypeScript/React.js 基本三套組外，還用了之前被分享到 Raycast Slack 社群的 <a href="https://github.com/pacocoursey/cmdk">cmdk</a>，他也是深深受到了 Raycast API 的影響，看看他 API 長那什麼樣子就知道。cmdk 還實作了 Raycast <strong>完全に一致</strong> 的主題，所以我就直接搬過來用了，哈，哈。</p>
<h2 id="%E5%81%9A%E5%88%B0%E5%8F%AF%E4%BB%A5-demo-%E7%9A%84%E7%A8%8B%E5%BA%A6%E5%95%A6%EF%BC%9Atodo-list-demo"><a class="anchor" href="#%E5%81%9A%E5%88%B0%E5%8F%AF%E4%BB%A5-demo-%E7%9A%84%E7%A8%8B%E5%BA%A6%E5%95%A6%EF%BC%9Atodo-list-demo"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> 做到可以 Demo 的程度啦：Todo List Demo</h2>
<p>欸，你以為這張要放在最前面嗎，放這麼下面就是要騙你捲到最後啦！</p>
<p>以下的錄影，就展示了在 Blast 使用 Raycast Todo list 擴充功能的 Create/Read/Delete 等操作。除了擴充功能本身一行未改，就連<a href="https://icon.ray.so/">圖示也是原汁原味</a>，滿足感之高，值得在半夜吶喊大吼吵醒各位室友們！！</p>
<figure data-type="image"><img src="https://hackmd.io/_uploads/ry79Ydl9o.png" alt=""></figure>
<p>雖然 Demo Driven Development/Talk DD/Blog DD 的推力只能讓我實作到這，但還是想慢慢把剩下來的 Raycast API 弄完啊，如果看我幾週後都沒 commit，那大概就是這樣了 XD（哪樣）</p>
<p>除了我實作的 <a href="https://github.com/Yukaii/blast">Blast</a> 之外，最近還看到兩個啟動器專案，彷彿都受到了 Raycast 的感召，下面簡單介紹一下：</p>
<h3 id="sunbeam-launcher"><a class="anchor" href="#sunbeam-launcher"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> <a href="https://github.com/sunbeamlauncher/sunbeam">Sunbeam Launcher</a></h3>
<p>作者本人也是 Raycast 擴充功能的貢獻者之一，我也是看到他在 Slack 社群裡分享的。Raycast heavily inspired，從專案名稱就看的出來 XD</p>
<p>Sunbeam 的擴充功能就是輸出 JSON 格式的 <a href="https://github.com/sunbeamlauncher/sunbeam/tree/main/examples">Shell Script</a>，所以可以用各種語言來寫，或是編譯成執行檔，反正 output 出來就沒你的事了。Sunbeam cli 會提供類似 Raycast 的 TUI 當做使用者介面來用，夠 Geek！夠帥！</p>
<p><a href="https://github.com/sunbeamlauncher/sunbeam-gui">真 GUI 部分</a>，目前實作是直接拿 xterm.js 跑 sunbeam cli 的 TUI 來當 UI，直到昨天都還在 commit 而已，讓我們期待後續發展。</p>
<h3 id="script-kit"><a class="anchor" href="#script-kit"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> <a href="https://www.scriptkit.com/">Script kit</a></h3>
<p>開源 &amp; MIT Licensed，同樣基於萬惡 Electron，JavaScript 生態系。原本看名稱以為是只支援到 Script 粒度，看了 <a href="https://github.com/johnlindquist/kit/blob/main/API.md">API</a> 發現能做的事還不少，Launcher 界明日之星！</p>
<hr>
<p>說著說著我們 Launcher 光譜圖都可以畫<s>滑</s>起來了，從前端選擇、跨平臺與否、生態圈 API 開放程度以及技術選擇，做產品總是個大坑啊，二ㄏ、二ㄏ</p>
<h2 id="%E9%B3%B4%E8%AC%9D"><a class="anchor" href="#%E9%B3%B4%E8%AC%9D"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> 鳴謝</h2>
<p>謝謝 <a href="https://chat.openai.com/chat">ChatGPT</a>，在我寫扣<s>無聊的時候陪我聊天</s>，在我懶的 Google 的時候幫助<s>坑</s>我。</p>
<p>謝謝 <a href="https://github.com/features/copilot">Copilot</a>，在我懶的打字的時候幫助我成為更好的 Tab 鍵工程師。</p>
<p>謝謝<a href="https://bocchi.rocks/">孤獨搖滾</a>，在我累的時候，心中的虹太陽燃起了我的動力。</p>
<p>本篇文章還沒有使用 AI 校稿，但是我的 <a href="https://github.com/Yukaii/blast">GitHub README</a> 有 ChatGPT 幫忙潤稿。</p>
</article></main></div><div class="container py-3 px-3"><div class="container-block color-bg-info color-border-info rounded-2 p-3">本篇文章驕傲的使用 <a class="no-underline color-text-primary text-semibold" href="https://hackmd.io" target="_blank" rel="noopener noreferrer"><i class="fas fa-file-alt"></i> HackMD</a> <a target="_blank" href="https://hackmd.io/s/5l5d-OQDQcy4xdTOOMmcMg" rel="noopener noreferrer">發佈</a></div></div><div class="container py-3 px-3"><div id="disqus_thread"></div></div></div></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"content":"\n# Blast：一個能執行 Raycast 擴充功能的 React.js 渲染器\n\n2023 年新年快樂！新年有什麼一定要做的事呢？對我來說就是挖新坑寫新專案無誤！這次的專案叫做 Blast，就如標題寫的，它是一個「能執行 Raycast 擴充功能的 React.js 渲染器（Renderer）」。\n\n## Raycast 和 React.js\n\n對於第一次聽到 [Raycast](https://www.raycast.com/) 的朋友，我以前也寫過一篇[推坑文][blog-post]，Raycast 是一套 macOS 用的啟動器軟體（Launcher），提供一個關鍵字搜尋的介面，輸入關鍵字，就能快速啟動程式或進行其他操作。過往類似的軟體也不少，最知名的就是 [Alfred](https://www.alfredapp.com/)，但 Raycast 最不同的一點，就是可以用 React.js 來寫的擴充功能。這邊我之前的文章也有[簡略帶過][blog-post]，大家可以看官方的 [todo-list 範例](https://github.com/raycast/extensions/tree/main/examples/todo-list)感受一下，有點像在寫 React Native，雖然寫的是 JavaScript，但卻能有原生的介面而非網頁。\n\n[blog-post]: https://yukai.dev/blog/2022/05/20/raycast-for-developers\n\nReact.js 相信近年熟悉前端開發的朋友應該都多少接觸過（斷言），React.js 提供了聲明式（Declarative）的 API 來開發使用者介面（User Interface），而使用者介面可以用階層、樹狀的結構來表示，去看看設計師 Figma/illustrator/Sketch 裡的圖層和群組物件就有感覺了，有的設計工具甚至還提供「輸出 React.js 元件」的功能。\n\n剛提到了「用 React 來實作使用者元件」，React 核心就是一套 Virtual DOM/Diff/Update 的邏輯，無關終端平臺為合，Android、iOS 還是 Desktop，只要你實作 React 提供的介面，什麼平臺都可以寫 React，所以才有了 React Native 等[一眾自定渲染器](https://github.com/chentsulin/awesome-react-renderer)（Custom Renderer）。\n\nRaycast 能夠用 React 來寫擴充功能，也是內嵌（ㄑㄧㄢ，誰這裡念砍我就...）Node.js 並實作渲染器。寫到這，Raycast 和 React 和 Renderer 的關係，大家應該多瞭解一咪咪了吧 XD 下面就來講講我為何決定做這個題目。\n\n## 動機\n\n七個字：Raycast 我推我超！\n\n從擴充功能 API 上線一年多以來，我已經寫了[十個 Raycast 擴充功能](https://www.raycast.com/Yukai)，還因此收到了 Raycast 寄來的[開發者大禮包](https://www.facebook.com/photo.php?fbid=6185229718163261\u0026set=p.6185229718163261\u0026type=3)。Raycast 有著 **Tier 0** 的開發者體驗，雖說頭幾個寫的擴充功能拿來練手成分比較高，但後期開發的擴充功能如 [HackMD](https://www.raycast.com/Yukai/hackmd) ，我自己都天天在用啊，開筆記搜筆記都超快超方便的（棒讀業配環節）\n\n另一個比較黑的理由就是我內心的[平衡人真島大哥](https://lycoris-recoil.com/)在作祟！隨著 Raycast 開發者社群的壯大，截止行文當日（2023/1/2）已上架 742 個擴充功能，雖然擴充功能的開源授權為 MIT，但除了拿來做擴充功能開發做參考外，這些擴充功能也只能跑在 Raycast 的封閉平臺上，除了僅限一家也僅限 macOS 一個平臺。\n\n我就想到 [VSCodium](https://vscodium.com/) 這個專案，雖然 VSCode 也是開放程式碼，但實際上的發佈版，還是包了遙測和一些追蹤碼。欸，全球的**軟黑產業鏈**似乎都動起來了！VSCodium 就是把 VSCode 有疑慮的授權程式碼部分和遙測通通拔掉，重新發佈的「乾淨版」。這樣 484 在臭各種 SaaS 產品啊 XD\n\n至於擴充功能商店的部分當然也不放過，[Open VSX](https://open-vsx.org/) 是一個提供相容 VSCode 編輯器的擴充功能商店。VSCode 至今已經被作為各個開源 IDE/編輯器的基礎元件來使用，比如用 Theia IDE 做的 IDE 們，就是相容 VSCode 擴充功能的 IDE。Open VSX 讓這些支援的編輯器也能免費擼 VSCode 平臺的擴充功能，打不贏就加入！\n\n總之，「**讓 Raycast 的擴充功能被跨平臺並開放地使用**」，就是本專案的目標！Show me what you got!\n\n## 開發 Blast\n\n[Blast](https://github.com/Yukaii/blast) 就是基於上述理由所發起的專案。這兩週陸陸續續的開發過程可以分成三個階段：\n\n- 架構設計、技術選擇與基本踩雷試錯\n- React 渲染器 \u0026 後端開發\n- Client App 開發\n\n### 架構設計、技術選擇與基本踩雷試錯\n\n開發過程和往常一樣，都丟在我的 [GitHub](https://github.com/Yukaii/blast) 上，這次還額外開了 [Project Board](https://github.com/users/Yukaii/projects/4) 來試用。\n\n一開始我就[決定目標](https://github.com/Yukaii/blast/issues/3)：要把 Raycast 官方擴充功能範例中 [Todo List](https://github.com/raycast/extensions/tree/main/examples/todo-list) 原汁原味一刀未減的跑起來。寫完這張 Ticket 後，就開始研究 Custom React renderer 該怎麼實作，最後找到 Jam Risser 的 [Building a Custom React Renderer](https://www.youtube.com/watch?v=SXx-CymMjDM)，演講內容和程式碼範例都相當清楚，值得參考。\n\n再來就是撞牆階段，一開始問 ChatGPT 用 Rollup 該怎麽設定 package alias，因為原始的 Raycast 擴充功能會用 `import { XXX } from '@raycast/api'`，而 `@raycast/api` 正式要替換為我自己實作的部分。沒想到開始用 Rollup 才是噩夢的開始，因為我要做的是 Application，鐵定會有一堆有的沒的相依套件，但我本來想把寫的程式打包成 ESM，於是在浪費一堆時間後就直接果斷換回熟悉的 Webpack，半小時內搞定 XD\n\n在瘋狂搗鼓 React Renderer 並有了基本理解後，我設計了以下的架構：\n\n![](https://hackmd.io/_uploads/rJmutOg9j.png)\n\n\n明明是個本機跑的 Launcher App 卻還要弄前後端？這裡的設計我很大的參考了早期的 React native。要寫一個自己的 React Renderer，我們會用到 `react-reconciler` 這個套件，並且實現 Host Config，大概會像[這個檔案一樣](https://github.com/Yukaii/blast/blob/b201eded481b8c54b3e3f38e2284a44a86dd0aee/src/reconciler.ts#L39-L77)：\n\n```javascript\nimport Reconciler from \"react-reconciler\";\n\nconst MyCustomReactRenderer = Reconciler({\n  createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n    // ....\n  },\n  appendChildToContainer(container, child) {\n    // ...\n  }\n})\n```\n\nHost Config 就是 Reconciler 函式的參數。你會看到一些類似操作 DOM 的方法，例如 `appendChild`，`removeChild` 等，因為那就是實作給 React 內部更新機制：Reconciliation 呼叫的方法。React 經由一系列騷操作，決定要更新的內容時，就會呼叫 Host Config 提供的方法，更新內容到你的目標平臺上。比如 [ReactDOM 就是實作了操作 DOM 的 Host Config](https://github.com/facebook/react/blob/de7d1c90718ea8f4844a2219991f7115ef2bd2c5/packages/react-dom-bindings/src/client/ReactDOMHostConfig.js)，React.js 才能將元件渲染到網頁上。\n\n上一段極其簡陋的說明了 React renderer 和 reconciler 的關係。說回來 React Native，在之前的 React Native 版本，Renderer 部分運用 Bridge Service，讓 JS engine 與 Native 部分溝通，你可以想象 React 內部在構建一顆樹狀結構，所以呼叫 `appendChild` 那些方法，Renderer 會把這些操作和參數佇列轉成 JSON 送到 Bridge，讓訂閱 Bridge 的 Native 端也一樣建造一棵樹（Shadow Tree），Native 端再由這顆樹狀的資料結構將原生的元件產生出來。\n\n之前的 React Native 用 JSON Bridge 來溝通，那 Blast 也用這個方法就好？但 React Native 傳送的是建造樹的操作過程（operation），在 Native 端還要實作各個方法，讓 Native 端也能依照操作建立樹結構。不過我沒有甚麼效能要求，直接透過 JSON 序列化傳送整顆樹過去還比較快，使用者端甚至還可以用 React.js 直接把樹渲染，反正 React 會幫我處裡 Diffing/Re-render，我只要負責把 React Component Tree 建出來就好啦！**Use React Everywhere**！**Learn Once Write Everywhere**！諾貝爾獎是我的啦！好耶！！！努力！未來！A Beautiful Star！\n\n以上就是在摸索中慢慢確立的 Blast 架構，剩下來的就是：實作！實作！實作！\n\n### React 渲染器 \u0026 後端開發\n\n老實說這部分在主架構實作完後就沒遇到太多困難，都是在填肉。比較值得一提的是我用了 [`rpc-websocket`](https://github.com/elpheria/rpc-websockets) 這套雙向 RPC 溝通的 Library。\n\n為何需要雙向？在上面提到的 Blast 架構中，前端需要拿到後端建立的 Component Tree（client request server），後端在更新時也需要通知前端（server request client），前端有事件需要觸發時，也需要通知後端（client request server），所以請求其實是雙向的。RPC library 會幫你處理好 function parameter serialization/deserialization/dynamic event registration 等麻煩事，所以直接找一套現有的還是最快。謝謝你，開源超人。\n\n### Client App 開發\n\n最後就是麻煩但挑戰性相對本專案後端低的前端部分。本來想試一下 [Tauri](https://tauri.app/) 還是 [Wails](https://wails.io/) 的，但查了一下 menubar API 的部分還是那個萬惡 JS World 的 Electron 支援比較完整及簡單，反正就是層 Web 皮嘛，就還是用了 Electron（逃）\n\n下面的動圖是 Blast 前端的 DevTool，可以看到目前渲染的 JSON Component Tree 長怎麼樣，也可以送 `rpc` 的事件給後端。\n\n![](https://hackmd.io/_uploads/BJqFK_x9s.png)\n\n\n元件部分，除了 Tailwind/TypeScript/React.js 基本三套組外，還用了之前被分享到 Raycast Slack 社群的 [cmdk](https://github.com/pacocoursey/cmdk)，他也是深深受到了 Raycast API 的影響，看看他 API 長那什麼樣子就知道。cmdk 還實作了 Raycast **完全に一致** 的主題，所以我就直接搬過來用了，哈，哈。\n\n## 做到可以 Demo 的程度啦：Todo List Demo\n\n欸，你以為這張要放在最前面嗎，放這麼下面就是要騙你捲到最後啦！\n\n以下的錄影，就展示了在 Blast 使用 Raycast Todo list 擴充功能的 Create/Read/Delete 等操作。除了擴充功能本身一行未改，就連[圖示也是原汁原味](https://icon.ray.so/)，滿足感之高，值得在半夜吶喊大吼吵醒各位室友們！！\n\n![](https://hackmd.io/_uploads/ry79Ydl9o.png)\n\n\n雖然 Demo Driven Development/Talk DD/Blog DD 的推力只能讓我實作到這，但還是想慢慢把剩下來的 Raycast API 弄完啊，如果看我幾週後都沒 commit，那大概就是這樣了 XD（哪樣）\n\n除了我實作的 [Blast](https://github.com/Yukaii/blast) 之外，最近還看到兩個啟動器專案，彷彿都受到了 Raycast 的感召，下面簡單介紹一下：\n\n### [Sunbeam Launcher](https://github.com/sunbeamlauncher/sunbeam)\n\n作者本人也是 Raycast 擴充功能的貢獻者之一，我也是看到他在 Slack 社群裡分享的。Raycast heavily inspired，從專案名稱就看的出來 XD\n\nSunbeam 的擴充功能就是輸出 JSON 格式的 [Shell Script](https://github.com/sunbeamlauncher/sunbeam/tree/main/examples)，所以可以用各種語言來寫，或是編譯成執行檔，反正 output 出來就沒你的事了。Sunbeam cli 會提供類似 Raycast 的 TUI 當做使用者介面來用，夠 Geek！夠帥！\n\n[真 GUI 部分](https://github.com/sunbeamlauncher/sunbeam-gui)，目前實作是直接拿 xterm.js 跑 sunbeam cli 的 TUI 來當 UI，直到昨天都還在 commit 而已，讓我們期待後續發展。\n\n### [Script kit](https://www.scriptkit.com/)\n\n開源 \u0026 MIT Licensed，同樣基於萬惡 Electron，JavaScript 生態系。原本看名稱以為是只支援到 Script 粒度，看了 [API](https://github.com/johnlindquist/kit/blob/main/API.md) 發現能做的事還不少，Launcher 界明日之星！\n\n---\n\n說著說著我們 Launcher 光譜圖都可以畫~~滑~~起來了，從前端選擇、跨平臺與否、生態圈 API 開放程度以及技術選擇，做產品總是個大坑啊，二ㄏ、二ㄏ\n\n## 鳴謝\n\n謝謝 [ChatGPT](https://chat.openai.com/chat)，在我寫扣~~無聊的時候陪我聊天~~，在我懶的 Google 的時候幫助~~坑~~我。\n\n謝謝 [Copilot](https://github.com/features/copilot)，在我懶的打字的時候幫助我成為更好的 Tab 鍵工程師。\n\n謝謝[孤獨搖滾](https://bocchi.rocks/)，在我累的時候，心中的虹太陽燃起了我的動力。\n\n本篇文章還沒有使用 AI 校稿，但是我的 [GitHub README](https://github.com/Yukaii/blast) 有 ChatGPT 幫忙潤稿。\n\n","title":"Blast：一個能執行 Raycast 擴充功能的 React.js 渲染器","params":{"year":"2023","month":"01","day":"02","slug":"blast-the-raycast-extension-react-renderer"},"disqus":{"shortname":"dailyoops","domain":"yukaii.tw"},"noteId":"5l5d-OQDQcy4xdTOOMmcMg","meta":{"published":true,"date":"2023-01-02 23:40"}},"__N_SSG":true},"page":"/blog/[year]/[month]/[day]/[slug]","query":{"year":"2023","month":"01","day":"02","slug":"blast-the-raycast-extension-react-renderer"},"buildId":"BIh5gQ5s5AG9U8UJ_rYWZ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>